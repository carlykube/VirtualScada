This project is a \doxyref{P\+H\+P}{p.}{namespace_p_h_p} 5.\+2 to \doxyref{P\+H\+P}{p.}{namespace_p_h_p} 5.\+6 parser {\bfseries written in \doxyref{P\+H\+P}{p.}{namespace_p_h_p} itself}.

\subsection*{What is this for? }

\doxyref{A}{p.}{class_a} parser is useful for {\tt static analysis}, manipulation of code and basically any other application dealing with code programmatically. \doxyref{A}{p.}{class_a} parser constructs an {\tt Abstract Syntax Tree} (A\+S\+T) of the code and thus allows dealing with it in an abstract and robust way.

There are other ways of processing source code. \doxyref{One}{p.}{class_one} that \doxyref{P\+H\+P}{p.}{namespace_p_h_p} supports natively is using the token stream generated by {\tt `token\+\_\+get\+\_\+all`}. The token stream is much more low level than the A\+S\+T and thus has different applications\+: It allows to also analyze the exact formatting of a file. On the other hand the token stream is much harder to deal with for more complex analysis. For example an A\+S\+T abstracts away the fact that in \doxyref{P\+H\+P}{p.}{namespace_p_h_p} variables can be written as {\ttfamily \$foo}, but also as {\ttfamily \$\$bar}, `\$\{\textquotesingle{}foobar\textquotesingle{}\}{\ttfamily or even}\$\{!\$\{\textquotesingle{}\textquotesingle{}\}=barfoo()\}`. You don\textquotesingle{}t have to worry about recognizing all the different syntaxes from a stream of tokens.

Another questions is\+: Why would I want to have a \doxyref{P\+H\+P}{p.}{namespace_p_h_p} parser {\itshape written in \doxyref{P\+H\+P}{p.}{namespace_p_h_p}}? Well, \doxyref{P\+H\+P}{p.}{namespace_p_h_p} might not be a language especially suited for fast parsing, but processing the A\+S\+T is much easier in \doxyref{P\+H\+P}{p.}{namespace_p_h_p} than it would be in other, faster languages like C. Furthermore the people most probably wanting to do programmatic \doxyref{P\+H\+P}{p.}{namespace_p_h_p} code analysis are incidentally \doxyref{P\+H\+P}{p.}{namespace_p_h_p} developers, not C developers.

\subsection*{What can it parse? }

The parser uses a \doxyref{P\+H\+P}{p.}{namespace_p_h_p} 5.\+6 compliant grammar, which is backwards compatible with all \doxyref{P\+H\+P}{p.}{namespace_p_h_p} version from \doxyref{P\+H\+P}{p.}{namespace_p_h_p} 5.\+2 upwards (and maybe older).

As the parser is based on the tokens returned by {\ttfamily token\+\_\+get\+\_\+all} (which is only able to lex the \doxyref{P\+H\+P}{p.}{namespace_p_h_p} version it runs on), additionally a wrapper for emulating new tokens from 5.\+3, 5.\+4, 5.\+5 and 5.\+6 is provided. This allows to parse \doxyref{P\+H\+P}{p.}{namespace_p_h_p} 5.\+6 source code running on \doxyref{P\+H\+P}{p.}{namespace_p_h_p} 5.\+3, for example. This emulation is very hacky and not perfect, but it should work well on any sane code.

\subsection*{What output does it produce? }

The parser produces an {\tt Abstract Syntax Tree} (A\+S\+T) also known as a node tree. How this looks like can best be seen in an example. The program `$<$?php echo \textquotesingle{}Hi\textquotesingle{}, \textquotesingle{}World\textquotesingle{};` will give you a node tree roughly looking like this\+:

``` array( 0\+: Stmt\+\_\+\+Echo( exprs\+: array( 0\+: Scalar\+\_\+\+String( value\+: Hi ) 1\+: Scalar\+\_\+\+String( value\+: World ) ) ) ) ```

This matches the structure of the code\+: An echo statement, which takes two strings as expressions, with the values {\ttfamily Hi} and {\ttfamily World!}.

You can also see that the A\+S\+T does not contain any whitespace information (but most comments are saved). So using it for formatting analysis is not possible.

\subsection*{What else can it do? }

Apart from the parser itself this package also bundles support for some other, related features\+:


\begin{DoxyItemize}
\item Support for pretty printing, which is the act of converting an A\+S\+T into \doxyref{P\+H\+P}{p.}{namespace_p_h_p} code. Please note that \char`\"{}pretty printing\char`\"{} does not imply that the output is especially pretty. It\textquotesingle{}s just how it\textquotesingle{}s called ;)
\item Support for serializing and unserializing the node tree to X\+M\+L
\item Support for dumping the node tree in a human readable form (see the section above for an example of how the output looks like)
\item Infrastructure for traversing and changing the A\+S\+T (node traverser and node visitors)
\item \doxyref{A}{p.}{class_a} node visitor for resolving namespaced names 
\end{DoxyItemize}