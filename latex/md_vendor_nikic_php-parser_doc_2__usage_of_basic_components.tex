This document explains how to use the parser, the pretty printer and the node traverser.

\subsection*{Bootstrapping }

The library needs to register a class autoloader. You can either use the {\ttfamily \doxyref{vendor/autoload.\+php}{p.}{vendor_2autoload_8php}} file generated by \doxyref{Composer}{p.}{namespace_composer} or by including the bundled {\ttfamily \doxyref{lib/bootstrap.\+php}{p.}{nikic_2php-parser_2lib_2bootstrap_8php}} file\+:

```php $<$?php require \textquotesingle{}path/to/\+P\+H\+P-\/\+Parser/lib/bootstrap.\+php\textquotesingle{}; // Or, if you\textquotesingle{}re using \doxyref{Composer}{p.}{namespace_composer}\+: require \textquotesingle{}path/to/vendor/autoload.\+php\textquotesingle{}; ```

Additionally you may want to set the {\ttfamily xdebug.\+max\+\_\+nesting\+\_\+level} ini option to a higher value\+:

```php $<$?php ini\+\_\+set(\textquotesingle{}xdebug.\+max\+\_\+nesting\+\_\+level\textquotesingle{}, 3000); ```

This ensures that there will be no errors when traversing highly nested node trees.

\subsection*{Parsing }

In order to parse some source code you first have to create a {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Parser} object, which needs to be passed a {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Lexer} instance\+:

```php $<$?php

\$parser = new \doxyref{Php\+Parser}{p.}{namespace_php_parser}(new \doxyref{Php\+Parser}{p.}{namespace_php_parser}); // or \$parser = new \doxyref{Php\+Parser}{p.}{namespace_php_parser}(new \doxyref{Php\+Parser}{p.}{namespace_php_parser}); ```

Use of the emulative lexer is required if you want to parse \doxyref{P\+H\+P}{p.}{namespace_p_h_p} code from newer versions than the one you\textquotesingle{}re running on. For example it will allow you to parse \doxyref{P\+H\+P}{p.}{namespace_p_h_p} 5.\+6 code while running on \doxyref{P\+H\+P}{p.}{namespace_p_h_p} 5.\+3.

Subsequently you can pass \doxyref{P\+H\+P}{p.}{namespace_p_h_p} code (including the opening {\ttfamily $<$?php} tag) to the {\ttfamily parse} method in order to create a syntax tree. If a syntax error is encountered, an {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}\doxyref{Error}{p.}{class_error}} exception will be thrown\+:

```php $<$?php \$code = \textquotesingle{}$<$?php // some code\textquotesingle{};

\$parser = new \doxyref{Php\+Parser}{p.}{namespace_php_parser}(new \doxyref{Php\+Parser}{p.}{namespace_php_parser});

try \{ \$stmts = \$parser-\/$>$parse(\$code); // \$stmts is an array of statement nodes \} catch (\doxyref{Php\+Parser}{p.}{namespace_php_parser} \$e) \{ echo \textquotesingle{}Parse \doxyref{Error}{p.}{class_error}\+: \textquotesingle{}, \$e-\/$>$get\+Message(); \} ```

\doxyref{A}{p.}{class_a} parser instance can be reused to parse multiple files.

\subsection*{Node tree }

If you use the above code with `\$code = \char`\"{}$<$?php echo \textquotesingle{}\+Hi \textquotesingle{}, hi\textbackslash{}\textbackslash{}get\+Target();\char`\"{}` the parser will generate a node tree looking like this\+:

``` array( 0\+: Stmt\+\_\+\+Echo( exprs\+: array( 0\+: Scalar\+\_\+\+String( value\+: Hi ) 1\+: Expr\+\_\+\+Func\+Call( name\+: Name( parts\+: array( 0\+: hi 1\+: get\+Target ) ) args\+: array( ) ) ) ) ) ```

Thus {\ttfamily \$stmts} will contain an array with only one node, with this node being an instance of {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Stmt\textbackslash{}Echo\+\_\+}.

As \doxyref{P\+H\+P}{p.}{namespace_p_h_p} is a large language there are approximately 140 different nodes. In order to make work with them easier they are grouped into three categories\+:


\begin{DoxyItemize}
\item {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Stmt}s are statement nodes, i.\+e. language constructs that do not return a value and can not occur in an expression. For example a class definition is a statement. It doesn\textquotesingle{}t return a value and you can\textquotesingle{}t write something like {\ttfamily func(class \doxyref{A}{p.}{class_a} \{\});}.
\item {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Expr}s are expression nodes, i.\+e. language constructs that return a value and thus can occur in other expressions. Examples of expressions are {\ttfamily \$var} ({\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Expr\textbackslash{}Variable}) and {\ttfamily func()} ({\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Expr\textbackslash{}Func\+Call}).
\item {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Scalar}s are nodes representing scalar values, like {\ttfamily \textquotesingle{}string\textquotesingle{}} ({\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Scalar\textbackslash{}String\+\_\+}), {\ttfamily 0} ({\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Scalar\textbackslash{}L\+Number}) or magic constants like {\ttfamily \+\_\+\+\_\+\+F\+I\+L\+E\+\_\+\+\_\+} ({\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Scalar\textbackslash{}Magic\+Const\textbackslash{}\doxyref{File}{p.}{class_file}}). All {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Scalar}s extend {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Expr}, as scalars are expressions, too.
\item There are some nodes not in either of these groups, for example names ({\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Name}) and call arguments ({\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}Arg}).
\end{DoxyItemize}

Some node class names have a trailing {\ttfamily \+\_\+}. This is used whenever the class name would otherwise clash with a \doxyref{P\+H\+P}{p.}{namespace_p_h_p} keyword.

Every node has a (possibly zero) number of subnodes. You can access subnodes by writing {\ttfamily \$node-\/$>$sub\+Node\+Name}. The {\ttfamily Stmt\textbackslash{}Echo\+\_\+} node has only one subnode {\ttfamily exprs}. So in order to access it in the above example you would write {\ttfamily \$stmts[0]-\/$>$exprs}. If you wanted to access the name of the function call, you would write {\ttfamily \$stmts[0]-\/$>$exprs[1]-\/$>$name}.

All nodes also define a {\ttfamily get\+Type()} method that returns the node type. The type is the class name without the {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\textbackslash{}} prefix and {\ttfamily \textbackslash{}} replaced with {\ttfamily \+\_\+}. It also does not contain a trailing {\ttfamily \+\_\+} for reserved-\/keyword class names.

It is possible to associate custom metadata with a node using the {\ttfamily set\+Attribute()} method. This data can then be retrieved using {\ttfamily has\+Attribute()}, {\ttfamily get\+Attribute()} and {\ttfamily get\+Attributes()}.

By default the lexer adds the {\ttfamily start\+Line}, {\ttfamily end\+Line} and {\ttfamily comments} attributes. {\ttfamily comments} is an array of {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Comment[\textbackslash{}Doc]} instances.

The start line can also be accessed using {\ttfamily get\+Line()}/{\ttfamily set\+Line()} (instead of `get\+Attribute(\textquotesingle{}start\+Line\textquotesingle{}){\ttfamily ). The last doc comment from the}comments{\ttfamily attribute can be obtained using}get\+Doc\+Comment()`.

\subsection*{Pretty printer }

The pretty printer component compiles the A\+S\+T back to \doxyref{P\+H\+P}{p.}{namespace_p_h_p} code. As the parser does not retain formatting information the formatting is done using a specified scheme. Currently there is only one scheme available, namely {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Pretty\+Printer\textbackslash{}Standard}.

```php $<$?php \$code = \char`\"{}$<$?php echo \textquotesingle{}\+Hi \textquotesingle{}, hi\textbackslash{}\textbackslash{}get\+Target();\char`\"{};

\$parser = new \doxyref{Php\+Parser}{p.}{namespace_php_parser}(new \doxyref{Php\+Parser}{p.}{namespace_php_parser}); \$pretty\+Printer = new \doxyref{Php\+Parser}{p.}{namespace_php_parser};

try \{ // parse \$stmts = \$parser-\/$>$parse(\$code);

// change \$stmts[0] // the echo statement -\/$>$exprs // sub expressions [0] // the first of them (the string node) -\/$>$value // it\textquotesingle{}s value, i.\+e. \textquotesingle{}Hi \textquotesingle{} = \textquotesingle{}Hello \textquotesingle{}; // change to \textquotesingle{}Hello \textquotesingle{}

// pretty print \$code = \$pretty\+Printer-\/$>$pretty\+Print(\$stmts);

echo \$code; \} catch (\doxyref{Php\+Parser}{p.}{namespace_php_parser} \$e) \{ echo \textquotesingle{}Parse \doxyref{Error}{p.}{class_error}\+: \textquotesingle{}, \$e-\/$>$get\+Message(); \} ```

The above code will output\+: \begin{DoxyVerb}<?php echo 'Hello ', hi\getTarget();
\end{DoxyVerb}


As you can see the source code was first parsed using {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Parser-\/$>$\doxyref{parse()}{p.}{d3_8min_8js_ae83605c3912b7dd2017d8889154727ad}}, then changed and then again converted to code using {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Pretty\+Printer\textbackslash{}Standard-\/$>$pretty\+Print()}.

The {\ttfamily pretty\+Print()} method pretty prints a statements array. It is also possible to pretty print only a single expression using {\ttfamily pretty\+Print\+Expr()}.

The {\ttfamily pretty\+Print\+File()} method can be used to print an entire file. This will include the opening {\ttfamily $<$?php} tag and handle inline \doxyref{H\+T\+M\+L}{p.}{class_h_t_m_l} as the first/last statement more gracefully.

\subsection*{Node traversation }

The above pretty printing example used the fact that the source code was known and thus it was easy to write code that accesses a certain part of a node tree and changes it. Normally this is not the case. Usually you want to change / analyze code in a generic way, where you don\textquotesingle{}t know how the node tree is going to look like.

For this purpose the parser provides a component for traversing and visiting the node tree. The basic structure of a program using this {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\+Traverser} looks like this\+:

```php $<$?php

\$parser = new \doxyref{Php\+Parser}{p.}{namespace_php_parser}(new \doxyref{Php\+Parser}{p.}{namespace_php_parser}); \$traverser = new \doxyref{Php\+Parser}{p.}{namespace_php_parser}; \$pretty\+Printer = new \doxyref{Php\+Parser}{p.}{namespace_php_parser};

// add your visitor \$traverser-\/$>$add\+Visitor(new My\+Node\+Visitor);

try \{ \$code = file\+\_\+get\+\_\+contents(\$file\+Name);

// parse \$stmts = \$parser-\/$>$parse(\$code);

// traverse \$stmts = \$traverser-\/$>$traverse(\$stmts);

// pretty print \$code = \$pretty\+Printer-\/$>$pretty\+Print\+File(\$stmts);

echo \$code; \} catch (\doxyref{Php\+Parser}{p.}{namespace_php_parser} \$e) \{ echo \textquotesingle{}Parse \doxyref{Error}{p.}{class_error}\+: \textquotesingle{}, \$e-\/$>$get\+Message(); \} ```

The corresponding node visitor might look like this\+:

```php $<$?php use \doxyref{Php\+Parser}{p.}{namespace_php_parser};

class My\+Node\+Visitor extends \doxyref{Php\+Parser}{p.}{namespace_php_parser} \{ public function leave\+Node(Node \$node) \{ if (\$node instanceof Node) \{ \$node-\/$>$value = \textquotesingle{}foo\textquotesingle{}; \} \} \} ```

The above node visitor would change all string literals in the program to {\ttfamily \textquotesingle{}foo\textquotesingle{}}.

All visitors must implement the {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\+Visitor} interface, which defines the following four methods\+: \begin{DoxyVerb}public function beforeTraverse(array $nodes);
public function enterNode(PhpParser\Node $node);
public function leaveNode(PhpParser\Node $node);
public function afterTraverse(array $nodes);
\end{DoxyVerb}


The {\ttfamily before\+Traverse()} method is called once before the traversal begins and is passed the nodes the traverser was called with. This method can be used for resetting values before traversation or preparing the tree for traversal.

The {\ttfamily after\+Traverse()} method is similar to the {\ttfamily before\+Traverse()} method, with the only difference that it is called once after the traversal.

The {\ttfamily enter\+Node()} and {\ttfamily leave\+Node()} methods are called on every node, the former when it is entered, i.\+e. before its subnodes are traversed, the latter when it is left.

All four methods can either return the changed node or not return at all (i.\+e. {\ttfamily null}) in which case the current node is not changed.

The {\ttfamily enter\+Node()} method can additionally return the value {\ttfamily Node\+Traverser\+::\+D\+O\+N\+T\+\_\+\+T\+R\+A\+V\+E\+R\+S\+E\+\_\+\+C\+H\+I\+L\+D\+R\+E\+N}, which instructs the traverser to skip all children of the current node.

The {\ttfamily leave\+Node()} method can additionally return the value {\ttfamily Node\+Traverser\+::\+R\+E\+M\+O\+V\+E\+\_\+\+N\+O\+D\+E}, in which case the current node will be removed from the parent array. Furthermove it is possible to return an array of nodes, which will be merged into the parent array at the offset of the current node. I.\+e. if in {\ttfamily array(\+A, B, C)} the node {\ttfamily B} should be replaced with {\ttfamily array(\+X, Y, Z)} the result will be {\ttfamily array(\+A, X, Y, Z, C)}.

Instead of manually implementing the {\ttfamily Node\+Visitor} interface you can also extend the {\ttfamily Node\+Visitor\+Abstract} class, which will define empty default implementations for all the above methods.

\subsection*{The Name\+Resolver node visitor }

\doxyref{One}{p.}{class_one} visitor is already bundled with the package\+: {\ttfamily \doxyref{Php\+Parser}{p.}{namespace_php_parser}\textbackslash{}Node\+Visitor\textbackslash{}Name\+Resolver}. This visitor helps you work with namespaced code by trying to resolve most names to fully qualified ones.

For example, consider the following code\+: \begin{DoxyVerb}use A as B;
new B\C();
\end{DoxyVerb}


In order to know that {\ttfamily B\textbackslash{}C} really is {\ttfamily \doxyref{A}{p.}{class_a}\textbackslash{}C} you would need to track aliases and namespaces yourself. The {\ttfamily Name\+Resolver} takes care of that and resolves names as far as possible.

After running it most names will be fully qualified. The only names that will stay unqualified are unqualified function and constant names. These are resolved at runtime and thus the visitor can\textquotesingle{}t know which function they are referring to. In most cases this is a non-\/issue as the global functions are meant.

Also the {\ttfamily Name\+Resolver} adds a {\ttfamily namespaced\+Name} subnode to class, function and constant declarations that contains the namespaced name instead of only the shortname that is available via {\ttfamily name}.

\subsection*{Example\+: Converting namespaced code to pseudo namespaces }

\doxyref{A}{p.}{class_a} small example to understand the concept\+: We want to convert namespaced code to pseudo namespaces so it works on 5.\+2, i.\+e. names like {\ttfamily \doxyref{A}{p.}{class_a}\textbackslash{}\textbackslash{}B} should be converted to {\ttfamily A\+\_\+\+B}. Note that such conversions are fairly complicated if you take \doxyref{P\+H\+P}{p.}{namespace_p_h_p}\textquotesingle{}s dynamic features into account, so our conversion will assume that no dynamic features are used.

We start off with the following base code\+:

```php $<$?php \$in\+Dir = \textquotesingle{}/some/path\textquotesingle{}; \$out\+Dir = \textquotesingle{}/some/other/path\textquotesingle{};

\$parser = new \doxyref{Php\+Parser}{p.}{namespace_php_parser}(new \doxyref{Php\+Parser}{p.}{namespace_php_parser}); \$traverser = new \doxyref{Php\+Parser}{p.}{namespace_php_parser}; \$pretty\+Printer = new \doxyref{Php\+Parser}{p.}{namespace_php_parser};

\$traverser-\/$>$add\+Visitor(new \doxyref{Php\+Parser}{p.}{namespace_php_parser}); // we will need resolved names \$traverser-\/$>$add\+Visitor(new Node\+Visitor); // our own node visitor

// iterate over all .php files in the directory \$files = new Recursive\+Iterator\+Iterator(new Recursive\+Directory\+Iterator(\$in\+Dir)); \$files = new Regex\+Iterator(\$files, \textquotesingle{}/.php\$/\textquotesingle{});

foreach (\$files as \$file) \{ try \{ // read the file that should be converted \$code = file\+\_\+get\+\_\+contents(\$file);

// parse \$stmts = \$parser-\/$>$parse(\$code);

// traverse \$stmts = \$traverser-\/$>$traverse(\$stmts);

// pretty print \$code = \$pretty\+Printer-\/$>$pretty\+Print\+File(\$stmts);

// write the converted file to the target directory file\+\_\+put\+\_\+contents( substr\+\_\+replace(\$file-\/$>$get\+Pathname(), \$out\+Dir, 0, strlen(\$in\+Dir)), \$code ); \} catch (\doxyref{Php\+Parser}{p.}{namespace_php_parser} \$e) \{ echo \textquotesingle{}Parse \doxyref{Error}{p.}{class_error}\+: \textquotesingle{}, \$e-\/$>$get\+Message(); \} \} ```

Now lets start with the main code, the {\ttfamily Node\+Visitor\textbackslash{}Namespace\+Converter}. \doxyref{One}{p.}{class_one} thing it needs to do is convert {\ttfamily \doxyref{A}{p.}{class_a}\textbackslash{}\textbackslash{}B} style names to {\ttfamily A\+\_\+\+B} style ones.

```php $<$?php use \doxyref{Php\+Parser}{p.}{namespace_php_parser}; class Node\+Visitor\+\_\+\+Namespace\+Converter extends \doxyref{Php\+Parser}{p.}{namespace_php_parser} \{ public function leave\+Node(Node \$node) \{ if (\$node instanceof Node) \{ return new Node(\$node-\/$>$to\+String(\textquotesingle{}\+\_\+\textquotesingle{})); \} \} \} ```

The above code profits from the fact that the {\ttfamily Name\+Resolver} already resolved all names as far as possible, so we don\textquotesingle{}t need to do that. We only need to create a string with the name parts separated by underscores instead of backslashes. This is what `\$node-\/$>$to\+String(\textquotesingle{}\+\_\+\textquotesingle{}){\ttfamily does. (If you want to create a name with backslashes either write}\$node-\/$>$\doxyref{to\+String()}{p.}{d3_8min_8js_ae8d464aecf1079781cef541fb9e18b3d}{\ttfamily or}(string) \$node`.) Then we create a new name from the string and return it. Returning a new node replaces the old node.

Another thing we need to do is change the class/function/const declarations. Currently they contain only the shortname (i.\+e. the last part of the name), but they need to contain the complete name inclduing the namespace prefix\+:

```php $<$?php use \doxyref{Php\+Parser}{p.}{namespace_php_parser}; use \doxyref{Php\+Parser}{p.}{namespace_php_parser}; class Node\+Visitor\+\_\+\+Namespace\+Converter extends \doxyref{Php\+Parser}{p.}{namespace_php_parser} \{ public function leave\+Node(Node \$node) \{ if (\$node instanceof Node) \{ return new Node(\$node-\/$>$to\+String(\textquotesingle{}\+\_\+\textquotesingle{})); \} elseif (\$node instanceof Stmt $\vert$$\vert$ \$node instanceof Stmt $\vert$$\vert$ \$node instanceof Stmt) \{ \$node-\/$>$name = \$node-\/$>$namespaced\+Name-\/$>$to\+String(\textquotesingle{}\+\_\+\textquotesingle{}); \} elseif (\$node instanceof Stmt) \{ foreach (\$node-\/$>$consts as \$const) \{ \$const-\/$>$name = \$const-\/$>$namespaced\+Name-\/$>$to\+String(\textquotesingle{}\+\_\+\textquotesingle{}); \} \} \} \} ```

There is not much more to it than converting the namespaced name to string with {\ttfamily \+\_\+} as separator.

The last thing we need to do is remove the {\ttfamily namespace} and {\ttfamily use} statements\+:

```php $<$?php use \doxyref{Php\+Parser}{p.}{namespace_php_parser}; use \doxyref{Php\+Parser}{p.}{namespace_php_parser}; class Node\+Visitor\+\_\+\+Namespace\+Converter extends \doxyref{Php\+Parser}{p.}{namespace_php_parser} \{ public function leave\+Node(Node \$node) \{ if (\$node instanceof Node) \{ return new Node(\$node-\/$>$to\+String(\textquotesingle{}\+\_\+\textquotesingle{})); \} elseif (\$node instanceof Stmt $\vert$$\vert$ \$node instanceof Stmt $\vert$$\vert$ \$node instanceof Stmt) \{ \$node-\/$>$name = \$node-\/$>$namespaced\+Name-\/$>$to\+String(\textquotesingle{}\+\_\+\textquotesingle{}); \} elseif (\$node instanceof Stmt) \{ foreach (\$node-\/$>$consts as \$const) \{ \$const-\/$>$name = \$const-\/$>$namespaced\+Name-\/$>$to\+String(\textquotesingle{}\+\_\+\textquotesingle{}); \} \} elseif (\$node instanceof Stmt) \{ // returning an array merges is into the parent array return \$node-\/$>$stmts; \} elseif (\$node instanceof Stmt) \{ // returning false removed the node altogether return false; \} \} \} ```

That\textquotesingle{}s all. 