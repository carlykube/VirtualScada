\section{protolibs.\+ics\+\_\+clients Namespace Reference}
\label{namespaceprotolibs_1_1ics__clients}\index{protolibs.\+ics\+\_\+clients@{protolibs.\+ics\+\_\+clients}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class {\bf I\+C\+S\+Client}
\item 
class {\bf Modbus\+Client}
\item 
class {\bf Modbus\+R\+T\+U}
\item 
class {\bf Modbus\+R\+T\+U\+Test}
\item 
class {\bf Modbus\+T\+C\+P}
\item 
class {\bf Modbus\+T\+C\+P\+Test}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def {\bf I\+C\+S\+Client\+Factory}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
tuple {\bf L\+O\+G\+G\+E\+R} = logging.\+get\+Logger(\char`\"{}modbus\+\_\+tk\char`\"{})
\item 
tuple {\bf tests} = {\bf Modbus\+T\+C\+P\+Test}()
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{protolibs\+::ics\+\_\+clients@{protolibs\+::ics\+\_\+clients}!I\+C\+S\+Client\+Factory@{I\+C\+S\+Client\+Factory}}
\index{I\+C\+S\+Client\+Factory@{I\+C\+S\+Client\+Factory}!protolibs\+::ics\+\_\+clients@{protolibs\+::ics\+\_\+clients}}
\subsubsection[{I\+C\+S\+Client\+Factory}]{\setlength{\rightskip}{0pt plus 5cm}def protolibs.\+ics\+\_\+clients.\+I\+C\+S\+Client\+Factory (
\begin{DoxyParamCaption}
\item[{}]{full\+\_\+config, }
\item[{}]{slave\+\_\+device, }
\item[{}]{master\+\_\+device, }
\item[{}]{icsiface\+\_\+index = {\ttfamily 0}, }
\item[{}]{clientiface\+\_\+index = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespaceprotolibs_1_1ics__clients_ae7cc4c8d5def58edbee74cd865091ad4}
\begin{DoxyVerb}Factory used to instantiate an ICS client from a config object.
    The configuration is read to choose which type of ICS client should be
    used, and an appropriate ICS client object is returned.

    @param full_config Configuration dictionary for the whole testbed
    @param slave_device name of the device that will be queried
    @param master_device name of the device that will do the querying
    @param icsifaceIndex Index of the interface we want to use in the 
                            list of icsifaces for this device
    @returns The appropriate ICS client object for the device.\end{DoxyVerb}
 

Definition at line 350 of file ics\+\_\+clients.\+py.



\subsection{Variable Documentation}
\index{protolibs\+::ics\+\_\+clients@{protolibs\+::ics\+\_\+clients}!L\+O\+G\+G\+E\+R@{L\+O\+G\+G\+E\+R}}
\index{L\+O\+G\+G\+E\+R@{L\+O\+G\+G\+E\+R}!protolibs\+::ics\+\_\+clients@{protolibs\+::ics\+\_\+clients}}
\subsubsection[{L\+O\+G\+G\+E\+R}]{\setlength{\rightskip}{0pt plus 5cm}tuple L\+O\+G\+G\+E\+R = logging.\+get\+Logger(\char`\"{}modbus\+\_\+tk\char`\"{})}\label{namespaceprotolibs_1_1ics__clients_ae9c29667350ae00a0837fc1e77c279e2}


Definition at line 31 of file ics\+\_\+clients.\+py.

\index{protolibs\+::ics\+\_\+clients@{protolibs\+::ics\+\_\+clients}!tests@{tests}}
\index{tests@{tests}!protolibs\+::ics\+\_\+clients@{protolibs\+::ics\+\_\+clients}}
\subsubsection[{tests}]{\setlength{\rightskip}{0pt plus 5cm}tuple tests = {\bf Modbus\+T\+C\+P\+Test}()}\label{namespaceprotolibs_1_1ics__clients_a6e64b5a4beec8eec41b9c30adfbafad3}


Definition at line 736 of file ics\+\_\+clients.\+py.

