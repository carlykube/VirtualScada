.TH "md_vendor_nikic_php-parser_doc_2__usage_of_basic_components" 3 "Tue Apr 14 2015" "Version 1.0" "VirtualSCADA" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_vendor_nikic_php-parser_doc_2__usage_of_basic_components \- Usage of basic components 
This document explains how to use the parser, the pretty printer and the node traverser\&.
.PP
.SS "Bootstrapping "
.PP
The library needs to register a class autoloader\&. You can either use the \fC\fBvendor/autoload\&.php\fP\fP file generated by \fBComposer\fP or by including the bundled \fC\fBlib/bootstrap\&.php\fP\fP file:
.PP
```php <?php require 'path/to/PHP-Parser/lib/bootstrap\&.php'; // Or, if you're using \fBComposer\fP: require 'path/to/vendor/autoload\&.php'; ```
.PP
Additionally you may want to set the \fCxdebug\&.max_nesting_level\fP ini option to a higher value:
.PP
```php <?php ini_set('xdebug\&.max_nesting_level', 3000); ```
.PP
This ensures that there will be no errors when traversing highly nested node trees\&.
.PP
.SS "Parsing "
.PP
In order to parse some source code you first have to create a \fC\fBPhpParser\fP\\Parser\fP object, which needs to be passed a \fC\fBPhpParser\fP\\Lexer\fP instance:
.PP
```php <?php
.PP
$parser = new \fBPhpParser\fP(new \fBPhpParser\fP); // or $parser = new \fBPhpParser\fP(new \fBPhpParser\fP); ```
.PP
Use of the emulative lexer is required if you want to parse \fBPHP\fP code from newer versions than the one you're running on\&. For example it will allow you to parse \fBPHP\fP 5\&.6 code while running on \fBPHP\fP 5\&.3\&.
.PP
Subsequently you can pass \fBPHP\fP code (including the opening \fC<?php\fP tag) to the \fCparse\fP method in order to create a syntax tree\&. If a syntax error is encountered, an \fC\fBPhpParser\fP\\\fBError\fP\fP exception will be thrown:
.PP
```php <?php $code = '<?php // some code';
.PP
$parser = new \fBPhpParser\fP(new \fBPhpParser\fP);
.PP
try { $stmts = $parser->parse($code); // $stmts is an array of statement nodes } catch (\fBPhpParser\fP $e) { echo 'Parse \fBError\fP: ', $e->getMessage(); } ```
.PP
\fBA\fP parser instance can be reused to parse multiple files\&.
.PP
.SS "Node tree "
.PP
If you use the above code with `$code = '<?php echo 'Hi ', hi\\\\getTarget();'` the parser will generate a node tree looking like this:
.PP
``` array( 0: Stmt_Echo( exprs: array( 0: Scalar_String( value: Hi ) 1: Expr_FuncCall( name: Name( parts: array( 0: hi 1: getTarget ) ) args: array( ) ) ) ) ) ```
.PP
Thus \fC$stmts\fP will contain an array with only one node, with this node being an instance of \fC\fBPhpParser\fP\\Node\\Stmt\\Echo_\fP\&.
.PP
As \fBPHP\fP is a large language there are approximately 140 different nodes\&. In order to make work with them easier they are grouped into three categories:
.PP
.IP "\(bu" 2
\fC\fBPhpParser\fP\\Node\\Stmt\fPs are statement nodes, i\&.e\&. language constructs that do not return a value and can not occur in an expression\&. For example a class definition is a statement\&. It doesn't return a value and you can't write something like \fCfunc(class \fBA\fP {});\fP\&.
.IP "\(bu" 2
\fC\fBPhpParser\fP\\Node\\Expr\fPs are expression nodes, i\&.e\&. language constructs that return a value and thus can occur in other expressions\&. Examples of expressions are \fC$var\fP (\fC\fBPhpParser\fP\\Node\\Expr\\Variable\fP) and \fCfunc()\fP (\fC\fBPhpParser\fP\\Node\\Expr\\FuncCall\fP)\&.
.IP "\(bu" 2
\fC\fBPhpParser\fP\\Node\\Scalar\fPs are nodes representing scalar values, like \fC'string'\fP (\fC\fBPhpParser\fP\\Node\\Scalar\\String_\fP), \fC0\fP (\fC\fBPhpParser\fP\\Node\\Scalar\\LNumber\fP) or magic constants like \fC__FILE__\fP (\fC\fBPhpParser\fP\\Node\\Scalar\\MagicConst\\\fBFile\fP\fP)\&. All \fC\fBPhpParser\fP\\Node\\Scalar\fPs extend \fC\fBPhpParser\fP\\Node\\Expr\fP, as scalars are expressions, too\&.
.IP "\(bu" 2
There are some nodes not in either of these groups, for example names (\fC\fBPhpParser\fP\\Node\\Name\fP) and call arguments (\fC\fBPhpParser\fP\\Node\\Arg\fP)\&.
.PP
.PP
Some node class names have a trailing \fC_\fP\&. This is used whenever the class name would otherwise clash with a \fBPHP\fP keyword\&.
.PP
Every node has a (possibly zero) number of subnodes\&. You can access subnodes by writing \fC$node->subNodeName\fP\&. The \fCStmt\\Echo_\fP node has only one subnode \fCexprs\fP\&. So in order to access it in the above example you would write \fC$stmts[0]->exprs\fP\&. If you wanted to access the name of the function call, you would write \fC$stmts[0]->exprs[1]->name\fP\&.
.PP
All nodes also define a \fCgetType()\fP method that returns the node type\&. The type is the class name without the \fC\fBPhpParser\fP\\Node\\\fP prefix and \fC\\\fP replaced with \fC_\fP\&. It also does not contain a trailing \fC_\fP for reserved-keyword class names\&.
.PP
It is possible to associate custom metadata with a node using the \fCsetAttribute()\fP method\&. This data can then be retrieved using \fChasAttribute()\fP, \fCgetAttribute()\fP and \fCgetAttributes()\fP\&.
.PP
By default the lexer adds the \fCstartLine\fP, \fCendLine\fP and \fCcomments\fP attributes\&. \fCcomments\fP is an array of \fC\fBPhpParser\fP\\Comment[\\Doc]\fP instances\&.
.PP
The start line can also be accessed using \fCgetLine()\fP/\fCsetLine()\fP (instead of `getAttribute('startLine')\fC)\&. The last doc comment from the\fPcomments\fCattribute can be obtained using\fPgetDocComment()`\&.
.PP
.SS "Pretty printer "
.PP
The pretty printer component compiles the AST back to \fBPHP\fP code\&. As the parser does not retain formatting information the formatting is done using a specified scheme\&. Currently there is only one scheme available, namely \fC\fBPhpParser\fP\\PrettyPrinter\\Standard\fP\&.
.PP
```php <?php $code = '<?php echo 'Hi ', hi\\\\getTarget();';
.PP
$parser = new \fBPhpParser\fP(new \fBPhpParser\fP); $prettyPrinter = new \fBPhpParser\fP;
.PP
try { // parse $stmts = $parser->parse($code);
.PP
// change $stmts[0] // the echo statement ->exprs // sub expressions [0] // the first of them (the string node) ->value // it's value, i\&.e\&. 'Hi ' = 'Hello '; // change to 'Hello '
.PP
// pretty print $code = $prettyPrinter->prettyPrint($stmts);
.PP
echo $code; } catch (\fBPhpParser\fP $e) { echo 'Parse \fBError\fP: ', $e->getMessage(); } ```
.PP
The above code will output: 
.PP
.nf
<?php echo 'Hello ', hi\getTarget();

.fi
.PP
.PP
As you can see the source code was first parsed using \fC\fBPhpParser\fP\\Parser->\fBparse()\fP\fP, then changed and then again converted to code using \fC\fBPhpParser\fP\\PrettyPrinter\\Standard->prettyPrint()\fP\&.
.PP
The \fCprettyPrint()\fP method pretty prints a statements array\&. It is also possible to pretty print only a single expression using \fCprettyPrintExpr()\fP\&.
.PP
The \fCprettyPrintFile()\fP method can be used to print an entire file\&. This will include the opening \fC<?php\fP tag and handle inline \fBHTML\fP as the first/last statement more gracefully\&.
.PP
.SS "Node traversation "
.PP
The above pretty printing example used the fact that the source code was known and thus it was easy to write code that accesses a certain part of a node tree and changes it\&. Normally this is not the case\&. Usually you want to change / analyze code in a generic way, where you don't know how the node tree is going to look like\&.
.PP
For this purpose the parser provides a component for traversing and visiting the node tree\&. The basic structure of a program using this \fC\fBPhpParser\fP\\NodeTraverser\fP looks like this:
.PP
```php <?php
.PP
$parser = new \fBPhpParser\fP(new \fBPhpParser\fP); $traverser = new \fBPhpParser\fP; $prettyPrinter = new \fBPhpParser\fP;
.PP
// add your visitor $traverser->addVisitor(new MyNodeVisitor);
.PP
try { $code = file_get_contents($fileName);
.PP
// parse $stmts = $parser->parse($code);
.PP
// traverse $stmts = $traverser->traverse($stmts);
.PP
// pretty print $code = $prettyPrinter->prettyPrintFile($stmts);
.PP
echo $code; } catch (\fBPhpParser\fP $e) { echo 'Parse \fBError\fP: ', $e->getMessage(); } ```
.PP
The corresponding node visitor might look like this:
.PP
```php <?php use \fBPhpParser\fP;
.PP
class MyNodeVisitor extends \fBPhpParser\fP { public function leaveNode(Node $node) { if ($node instanceof Node) { $node->value = 'foo'; } } } ```
.PP
The above node visitor would change all string literals in the program to \fC'foo'\fP\&.
.PP
All visitors must implement the \fC\fBPhpParser\fP\\NodeVisitor\fP interface, which defines the following four methods: 
.PP
.nf
public function beforeTraverse(array $nodes);
public function enterNode(PhpParser\Node $node);
public function leaveNode(PhpParser\Node $node);
public function afterTraverse(array $nodes);

.fi
.PP
.PP
The \fCbeforeTraverse()\fP method is called once before the traversal begins and is passed the nodes the traverser was called with\&. This method can be used for resetting values before traversation or preparing the tree for traversal\&.
.PP
The \fCafterTraverse()\fP method is similar to the \fCbeforeTraverse()\fP method, with the only difference that it is called once after the traversal\&.
.PP
The \fCenterNode()\fP and \fCleaveNode()\fP methods are called on every node, the former when it is entered, i\&.e\&. before its subnodes are traversed, the latter when it is left\&.
.PP
All four methods can either return the changed node or not return at all (i\&.e\&. \fCnull\fP) in which case the current node is not changed\&.
.PP
The \fCenterNode()\fP method can additionally return the value \fCNodeTraverser::DONT_TRAVERSE_CHILDREN\fP, which instructs the traverser to skip all children of the current node\&.
.PP
The \fCleaveNode()\fP method can additionally return the value \fCNodeTraverser::REMOVE_NODE\fP, in which case the current node will be removed from the parent array\&. Furthermove it is possible to return an array of nodes, which will be merged into the parent array at the offset of the current node\&. I\&.e\&. if in \fCarray(A, B, C)\fP the node \fCB\fP should be replaced with \fCarray(X, Y, Z)\fP the result will be \fCarray(A, X, Y, Z, C)\fP\&.
.PP
Instead of manually implementing the \fCNodeVisitor\fP interface you can also extend the \fCNodeVisitorAbstract\fP class, which will define empty default implementations for all the above methods\&.
.PP
.SS "The NameResolver node visitor "
.PP
\fBOne\fP visitor is already bundled with the package: \fC\fBPhpParser\fP\\NodeVisitor\\NameResolver\fP\&. This visitor helps you work with namespaced code by trying to resolve most names to fully qualified ones\&.
.PP
For example, consider the following code: 
.PP
.nf
use A as B;
new B\C();

.fi
.PP
.PP
In order to know that \fCB\\C\fP really is \fC\fBA\fP\\C\fP you would need to track aliases and namespaces yourself\&. The \fCNameResolver\fP takes care of that and resolves names as far as possible\&.
.PP
After running it most names will be fully qualified\&. The only names that will stay unqualified are unqualified function and constant names\&. These are resolved at runtime and thus the visitor can't know which function they are referring to\&. In most cases this is a non-issue as the global functions are meant\&.
.PP
Also the \fCNameResolver\fP adds a \fCnamespacedName\fP subnode to class, function and constant declarations that contains the namespaced name instead of only the shortname that is available via \fCname\fP\&.
.PP
.SS "Example: Converting namespaced code to pseudo namespaces "
.PP
\fBA\fP small example to understand the concept: We want to convert namespaced code to pseudo namespaces so it works on 5\&.2, i\&.e\&. names like \fC\fBA\fP\\\\B\fP should be converted to \fCA_B\fP\&. Note that such conversions are fairly complicated if you take \fBPHP\fP's dynamic features into account, so our conversion will assume that no dynamic features are used\&.
.PP
We start off with the following base code:
.PP
```php <?php $inDir = '/some/path'; $outDir = '/some/other/path';
.PP
$parser = new \fBPhpParser\fP(new \fBPhpParser\fP); $traverser = new \fBPhpParser\fP; $prettyPrinter = new \fBPhpParser\fP;
.PP
$traverser->addVisitor(new \fBPhpParser\fP); // we will need resolved names $traverser->addVisitor(new NodeVisitor); // our own node visitor
.PP
// iterate over all \&.php files in the directory $files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($inDir)); $files = new RegexIterator($files, '/\&.php$/');
.PP
foreach ($files as $file) { try { // read the file that should be converted $code = file_get_contents($file);
.PP
// parse $stmts = $parser->parse($code);
.PP
// traverse $stmts = $traverser->traverse($stmts);
.PP
// pretty print $code = $prettyPrinter->prettyPrintFile($stmts);
.PP
// write the converted file to the target directory file_put_contents( substr_replace($file->getPathname(), $outDir, 0, strlen($inDir)), $code ); } catch (\fBPhpParser\fP $e) { echo 'Parse \fBError\fP: ', $e->getMessage(); } } ```
.PP
Now lets start with the main code, the \fCNodeVisitor\\NamespaceConverter\fP\&. \fBOne\fP thing it needs to do is convert \fC\fBA\fP\\\\B\fP style names to \fCA_B\fP style ones\&.
.PP
```php <?php use \fBPhpParser\fP; class NodeVisitor_NamespaceConverter extends \fBPhpParser\fP { public function leaveNode(Node $node) { if ($node instanceof Node) { return new Node($node->toString('_')); } } } ```
.PP
The above code profits from the fact that the \fCNameResolver\fP already resolved all names as far as possible, so we don't need to do that\&. We only need to create a string with the name parts separated by underscores instead of backslashes\&. This is what `$node->toString('_')\fCdoes\&. (If you want to create a name with backslashes either write\fP$node->\fBtoString()\fP\fCor\fP(string) $node`\&.) Then we create a new name from the string and return it\&. Returning a new node replaces the old node\&.
.PP
Another thing we need to do is change the class/function/const declarations\&. Currently they contain only the shortname (i\&.e\&. the last part of the name), but they need to contain the complete name inclduing the namespace prefix:
.PP
```php <?php use \fBPhpParser\fP; use \fBPhpParser\fP; class NodeVisitor_NamespaceConverter extends \fBPhpParser\fP { public function leaveNode(Node $node) { if ($node instanceof Node) { return new Node($node->toString('_')); } elseif ($node instanceof Stmt || $node instanceof Stmt || $node instanceof Stmt) { $node->name = $node->namespacedName->toString('_'); } elseif ($node instanceof Stmt) { foreach ($node->consts as $const) { $const->name = $const->namespacedName->toString('_'); } } } } ```
.PP
There is not much more to it than converting the namespaced name to string with \fC_\fP as separator\&.
.PP
The last thing we need to do is remove the \fCnamespace\fP and \fCuse\fP statements:
.PP
```php <?php use \fBPhpParser\fP; use \fBPhpParser\fP; class NodeVisitor_NamespaceConverter extends \fBPhpParser\fP { public function leaveNode(Node $node) { if ($node instanceof Node) { return new Node($node->toString('_')); } elseif ($node instanceof Stmt || $node instanceof Stmt || $node instanceof Stmt) { $node->name = $node->namespacedName->toString('_'); } elseif ($node instanceof Stmt) { foreach ($node->consts as $const) { $const->name = $const->namespacedName->toString('_'); } } elseif ($node instanceof Stmt) { // returning an array merges is into the parent array return $node->stmts; } elseif ($node instanceof Stmt) { // returning false removed the node altogether return false; } } } ```
.PP
That's all\&. 
