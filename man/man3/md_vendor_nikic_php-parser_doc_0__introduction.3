.TH "md_vendor_nikic_php-parser_doc_0__introduction" 3 "Tue Apr 14 2015" "Version 1.0" "VirtualSCADA" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_vendor_nikic_php-parser_doc_0__introduction \- Introduction 
This project is a \fBPHP\fP 5\&.2 to \fBPHP\fP 5\&.6 parser \fBwritten in \fBPHP\fP itself\fP\&.
.PP
.SS "What is this for? "
.PP
\fBA\fP parser is useful for \fCstatic analysis\fP, manipulation of code and basically any other application dealing with code programmatically\&. \fBA\fP parser constructs an \fCAbstract Syntax Tree\fP (AST) of the code and thus allows dealing with it in an abstract and robust way\&.
.PP
There are other ways of processing source code\&. \fBOne\fP that \fBPHP\fP supports natively is using the token stream generated by \fC`token_get_all`\fP\&. The token stream is much more low level than the AST and thus has different applications: It allows to also analyze the exact formatting of a file\&. On the other hand the token stream is much harder to deal with for more complex analysis\&. For example an AST abstracts away the fact that in \fBPHP\fP variables can be written as \fC$foo\fP, but also as \fC$$bar\fP, `${'foobar'}\fCor even\fP${!${''}=barfoo()}`\&. You don't have to worry about recognizing all the different syntaxes from a stream of tokens\&.
.PP
Another questions is: Why would I want to have a \fBPHP\fP parser \fIwritten in \fBPHP\fP\fP? Well, \fBPHP\fP might not be a language especially suited for fast parsing, but processing the AST is much easier in \fBPHP\fP than it would be in other, faster languages like C\&. Furthermore the people most probably wanting to do programmatic \fBPHP\fP code analysis are incidentally \fBPHP\fP developers, not C developers\&.
.PP
.SS "What can it parse? "
.PP
The parser uses a \fBPHP\fP 5\&.6 compliant grammar, which is backwards compatible with all \fBPHP\fP version from \fBPHP\fP 5\&.2 upwards (and maybe older)\&.
.PP
As the parser is based on the tokens returned by \fCtoken_get_all\fP (which is only able to lex the \fBPHP\fP version it runs on), additionally a wrapper for emulating new tokens from 5\&.3, 5\&.4, 5\&.5 and 5\&.6 is provided\&. This allows to parse \fBPHP\fP 5\&.6 source code running on \fBPHP\fP 5\&.3, for example\&. This emulation is very hacky and not perfect, but it should work well on any sane code\&.
.PP
.SS "What output does it produce? "
.PP
The parser produces an \fCAbstract Syntax Tree\fP (AST) also known as a node tree\&. How this looks like can best be seen in an example\&. The program `<?php echo 'Hi', 'World';` will give you a node tree roughly looking like this:
.PP
``` array( 0: Stmt_Echo( exprs: array( 0: Scalar_String( value: Hi ) 1: Scalar_String( value: World ) ) ) ) ```
.PP
This matches the structure of the code: An echo statement, which takes two strings as expressions, with the values \fCHi\fP and \fCWorld!\fP\&.
.PP
You can also see that the AST does not contain any whitespace information (but most comments are saved)\&. So using it for formatting analysis is not possible\&.
.PP
.SS "What else can it do? "
.PP
Apart from the parser itself this package also bundles support for some other, related features:
.PP
.IP "\(bu" 2
Support for pretty printing, which is the act of converting an AST into \fBPHP\fP code\&. Please note that 'pretty printing' does not imply that the output is especially pretty\&. It's just how it's called ;)
.IP "\(bu" 2
Support for serializing and unserializing the node tree to XML
.IP "\(bu" 2
Support for dumping the node tree in a human readable form (see the section above for an example of how the output looks like)
.IP "\(bu" 2
Infrastructure for traversing and changing the AST (node traverser and node visitors)
.IP "\(bu" 2
\fBA\fP node visitor for resolving namespaced names 
.PP

