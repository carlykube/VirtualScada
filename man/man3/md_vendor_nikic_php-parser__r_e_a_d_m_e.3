.TH "md_vendor_nikic_php-parser__r_e_a_d_m_e" 3 "Tue Apr 14 2015" "Version 1.0" "VirtualSCADA" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_vendor_nikic_php-parser__r_e_a_d_m_e \- \fBPHP\fP Parser 
This is a \fBPHP\fP 5\&.2 to \fBPHP\fP 5\&.6 parser written in \fBPHP\fP\&. Its purpose is to simplify static code analysis and manipulation\&.
.PP
\fC**Documentation for version 1\&.x**\fP (stable; for running on \fBPHP\fP >= 5\&.3)\&.
.PP
\fCDocumentation for version 0\&.9\&.x\fP (unsupported; for running on \fBPHP\fP 5\&.2)\&.
.PP
.SS "In a Nutshell "
.PP
The parser turns \fBPHP\fP source code into an abstract syntax tree\&. For example, if you pass the following code into the parser:
.PP
```php <?php echo 'Hi', 'World'; hello('foo', 'bar' \&. 'baz'); ```
.PP
You'll get a syntax tree looking roughly like this:
.PP
``` array( 0: Stmt_Echo( exprs: array( 0: Scalar_String( value: Hi ) 1: Scalar_String( value: World ) ) ) 1: Expr_FuncCall( name: Name( parts: array( 0: hello 1: world ) ) args: array( 0: Arg( value: Scalar_String( value: foo ) byRef: false ) 1: Arg( value: Expr_Concat( left: Scalar_String( value: bar ) right: Scalar_String( value: baz ) ) byRef: false ) ) ) ) ```
.PP
You can then work with this syntax tree, for example to statically analyze the code (e\&.g\&. to find programming errors or security issues)\&.
.PP
Additionally, you can convert a syntax tree back to \fBPHP\fP code\&. This allows you to do code preprocessing (like automatedly porting code to older \fBPHP\fP versions)\&.
.PP
.SS "Documentation "
.PP
.IP "1." 4
\fBdoc\fP/0_Introduction\&.markdown 'Introduction'
.IP "2." 4
\fBdoc\fP/1_Installation\&.markdown 'Installation'
.IP "3." 4
\fBdoc\fP/2_Usage_of_basic_components\&.markdown 'Usage of basic components'
.IP "4." 4
\fBdoc\fP/3_Other_node_tree_representations\&.markdown 'Other node tree representations'
.IP "5." 4
\fBdoc\fP/4_Code_generation\&.markdown 'Code generation'
.PP
.PP
Component documentation:
.PP
.IP "1." 4
\fBLexer\fP 
.PP

